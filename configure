#! /bin/sh

### See http://people.gnome.org/~walters/docs/build-api.txt
# buildapi-variable-no-builddir

# Try to make different shells more sh-compatible.
#
DUALCASE=1; export DUALCASE # mksh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1 ; then :
	emulate sh
	NULLCMD=:
	alias -g '${1+"$@"}'='"$@"'
	setopt NO_GLOBSUBST
else
	case `(set -o) 2>/dev/null` in
		*posix*) :
			set -o posix ;;
		*) :
			;;
	esac
fi

cf_clean_program_files_on_exit=true
cf_clean_program_files () {
	if ${cf_clean_program_files}
	then
		rm -f \
			.cf_test.out \
			.cf_test.err \
			.cf_test.cmd \
			.cf_test.out \
			.cf_test.i \
			.cf_test.c \
			.cf_test
	fi
}

cf_clean_program_files
trap cf_clean_program_files EXIT

# Show help if requested.
#
cf_help_text='
Available options:

  --help           This help message.
  --prefix=PATH    Installation path prefix [default: /usr].
  --objdir=PATH    Build directory [default: $(pwd)].
  --debug          Do a debug build without optimizations.
  --enable-trace   Enable TRACE(), for debugging purposes.
  --enable-checks  Enable additional run-time sanity checks.
  --enable-asan    Compile with ASAN support (needs Clang).
  --enable-ffi     Use libffi instead of machine-specific code
                   to perform function calls.
  --enable-bundled-libdwarf
                   Use a bundled copy libdwarf instead of the
                   one supplied by the operating system.
  --enable-bundled-lua
                   Use a bundled copy of Lua instead of the
                   one supplied by the system.

The following environment variables, if set, will be honored:

  CC               C compiler to use.
  CFLAGS           Additional flags passed to the C compiler.
  CPPFLAGS         Additional flags passed to the C preprocessor.
  LDFLAGS          Additional flags passed to the linker.
  LIBS             Additional libraries to link binaries to.
  PKG_CONFIG_PATH  List of directories to search for .pc files.

NOTE: This script tries to mimic the behaviour of "configure" scripts
generated by GNU Autotools, and it will silently ignore unrecognized
command line options in order to do so.'

for var in "$@" ; do
	if test "${var}" = '--help' ; then
		echo "usage: $0 [options]${cf_help_text}"
		cf_clean_program_files_on_exit=false
		exit 0
	fi
done
unset var


cf_die () {
	cf_clean_program_files_on_exit=false
	echo "$*" 1>&2
	exit 1
}

cf_choose_program () {
	while test -n "$1" ; do
		if which "$1" > /dev/null 2>&1
		then
			which "$1"
			return
		fi
		shift
	done
}

cf_compiler_is_clang () {
	test 'clang ' = "$(expr substr "$($1 -v 2>&1)" 1 6)"
}

# Usage:
#   cf_test_program "program text"
# or:
#   cf_test_program <<EOF
#   program text
#   EOF
#
cf_test_program () {
	if test -n "$1" ; then
		echo "$1" > .cf_test.c
	else
		cat > .cf_test.c
	fi
}


cf_result=0

cf_test_passed () {
	test "x${cf_result}" = "x0"
}
cf_test_failed () {
	test "x${cf_result}" != "x0"
}

cf_result_yesno () {
	cf_test_passed && echo yes || echo no
}

cf_checking () {
	echo -n "Checking $* ... "
}

cf_check_result () {
	if test -n "$1"
	then
		echo "$*"
	else
		cf_result_yesno
	fi
}

# Usage:
#   cf_test_program ...
#   cf_test_link [compiler-flags]
#
cf_test_link__ () {
	echo "${CC} ${CPPFLAGS} ${CFLAGS} -o .cf_test .cf_test.c ${LDFLAGS} ${LIBS} $*" > .cf_test.cmd
	${CC} ${CPPFLAGS} ${CFLAGS} -o .cf_test .cf_test.c \
		${LDFLAGS} ${LIBS} "$@" > .cf_test.out 2> .cf_test.err
	cf_result=$?
	return ${cf_result}
}

# Usage:
#   cf_ensure_library -lfoo [compiler-flags]
#
cf_ensure_library () {
	cf_checking "whether $1 can be linked"
	cf_test_link__ "$@"
	cf_check_result
	cf_test_passed || cf_die "Library $1 is missing"
}

# Usage:
#   cf_test_function func -lfoo [compiler-flags]
#
cf_test_function () {
	if test -n "$2"
	then
		cf_checking "for $1() in $2"
	else
		cf_checking "for $1()"
	fi
	cf_test_program "extern int $1 (); int main () { return $1 (); }"
	shift
	cf_test_link__ "$@"
	cf_check_result
}

# Usage:
#   cf_ensure_function func -lfoo [compiler-flags]
#
cf_ensure_function () {
	cf_test_function "$@" || cf_die "Function $1 missing in $2"
}

# Usage:
#   cf_test_header "<header>" [compiler-flags]
#
cf_test_header () {
	cf_checking "for $1"
	cf_test_program "#include $1"
	shift
	echo "${CC} ${CPPFLAGS} ${CFLAGS} -o .cf_test.i .cf_test.c -E $*" > .cf_test.cmd
	${CC} ${CPPFLAGS} ${CFLAGS} -o .cf_test.i .cf_test.c \
		-E "$@" > .cf_test.out 2> .cf_test.err
	cf_result=$?
	cf_check_result
	return ${cf_result}
}

# Usage:
#   cf_ensure_header "<header>" [compiler-flags]
#
cf_ensure_header () {
	cf_test_header "$@" || cf_die "Header $1 is missing"
}

# Usage:
#   cf_pkg_config NAME pkgs [pkg-config-flags]
#
# Defines ${NAME_CFLAGS} and ${NAME_LIBS} using pkg-config
#
cf_pkg_config__=''
cf_pkg_config_name=''
cf_pkg_config_package=''
cf_pkg_config_cflags=''
cf_pkg_config_libs=''

cf_pkg_config () {
	if test "x${cf_pkg_config__}" = "x"
	then
		cf_pkg_config__=${PKG_CONFIG_PATH:-$(cf_choose_program pkg-config)}
	fi
	if test "x${cf_pkg_config__}" = "x"
	then
		cf_die 'pkg-config not found, make sure it is in your $PATH'
	fi

	cf_pkg_config_name=$1
	cf_pkg_config_package=$2
	shift
	shift

	cf_checking "for ${cf_pkg_config_name} (${cf_pkg_config_package})"
	"${cf_pkg_config__}" --exists "${cf_pkg_config_package}"
	cf_result=$?
	cf_check_result

	if cf_test_passed
	then
		cf_checking "for ${cf_pkg_config_name}_CFLAGS"
		cf_pkg_config_cflags=$("${cf_pkg_config__}" \
			--cflags "${cf_pkg_config_package}" "$@")
		eval "${cf_pkg_config_name}_CFLAGS='${cf_pkg_config_cflags}'"
		cf_check_result "${cf_pkg_config_cflags}"

		cf_checking "for ${cf_pkg_config_name}_LDFLAGS"
		cf_pkg_config_libs=$("${cf_pkg_config__}" \
			--libs "${cf_pkg_config_package}" "$@")
		eval "${cf_pkg_config_name}_LDFLAGS='${cf_pkg_config_libs}'"
		cf_check_result "${cf_pkg_config_libs}"
	fi
	return ${cf_result}
}

# Inherit variables from the environment, if defined. For tools,
# try to make a sensible choice by default.
#
test -n "${CPPFLAGS}" && EXTRA_CPPFLAGS=${CPPFLAGS}
test -n "${CFLAGS}"   && EXTRA_CFLAGS=${CFLAGS}
test -n "${CC}"       || CC=$(cf_choose_program clang gcc cc)

# We only support POSIX systems.
CPPFLAGS='-DLUA_USE_POSIX=1'

if cf_compiler_is_clang "${CC}" ; then
	CFLAGS='-Qunused-arguments -Wno-parentheses-equality -Wno-array-bounds'
fi

# Truncate "build.conf"
echo "# autogenerated by: $0 $*" > build.conf
cf_build_conf () {
	if test -n "$1"
	then
		echo "$*" >> build.conf
	else
		cat >> build.conf
	fi
}

# Inspect arguments and generate build.conf
#
debug_build=false
enable_asan=false
enable_trace=false
enable_checks=false
enable_ffi=false
enable_bundled_lua=false
enable_bundled_libdwarf=false
objdir=$(pwd)
for var in "$@" ; do
	case ${var} in
		CFLAGS=* | LDFLAGS=* | LIBS=*)
			echo "Setting EXTRA_${var}"
			echo "EXTRA_${var}" >> build.conf
			;;

		--prefix=*)
			var=$(echo "${var}" | sed 's/^--prefix=//')
			echo "Setting PREFIX=${var}"
			PREFIX=${var}
			;;

		--objdir=*)
			var=$(echo "${var}" | sed 's/^--objdir=//')
			echo "Setting objdir=${var}"
			objdir=${var}
			;;

		--debug)
			debug_build=true
			;;

		--enable-asan)
			enable_asan=true
			;;
		--disable-asan)
			enable_asan=false
			;;

		--enable-trace)
			enable_trace=true
			;;
		--disable-trace)
			enable_trace=false
			;;

		--enable-checks)
			enable_checks=true
			;;
		--disable-checks)
			enable_checks=false
			;;

		--enable-ffi)
			enable_ffi=true
			;;
		--disable-ffi)
			enable_ffi=false
			;;

		--enable-bundled-lua)
			enable_bundled_lua=true
			;;
		--disable-bundled-lua)
			enable_bundled_lua=false
			;;

		--enable-bundled-libdwarf)
			enable_bundled_libdwarf=true
			;;
		--disable-bundled-libdwarf)
			enable_bundled_libdwarf=false
			;;

		*)
			true
			;;
	esac
done


if ${debug_build}
then
	build_type='debug'
	CFLAGS="${CFLAGS} -O0 -g"
	LDFLAGS="${LDFLAGS} -g"
	CPPFLAGS="${CPPFLAGS} -DLUA_USE_APICHECK=1"
else
	build_type='release'
	CFLAGS="${CFLAGS} -O2 -g"
	#
	# All reasonably recent versions of Clang support LTO.
	#
	if cf_compiler_is_clang "${CC}"
	then
		CFLAGS="${CFLAGS} -flto"
		LDFLAGS="${LDFLAGS} -flto"
	fi
fi

if ${enable_asan}
then
	cf_compiler_is_clang "${CC}" || cf_die 'ASAN only works when building with Clang'
	LDFLAGS="${CFLAGS} -fsanitize=address"
	CFLAGS="${CFLAGS} -fsanitize=address"
	build_type="${build_type} (+asan)"
fi

if ${enable_trace}
then
	CPPFLAGS="${CPPFLAGS} -DERIS_TRACE=1"
	build_type="${build_type} (+trace)"
fi

if ${enable_checks}
then
	CPPFLAGS="${CPPFLAGS} -DERIS_RUNTIME_CHECKS=1"
	build_type="${build_type} (+check)"
fi

echo "Build type: ${build_type}"

# Mandatory headers and libraries.
cf_ensure_header '<dlfcn.h>'
cf_ensure_header '<libelf.h>'
cf_ensure_function elf_begin -lelf


cf_checking 'whether to use bundled libdwarf'
if ${enable_bundled_libdwarf}
then
	libdwarf_build_type='bundled'
	cf_check_result yes
else
	libdwarf_build_type='system'
	cf_check_result no

	if cf_test_header '<libdwarf/libdwarf.h>'
	then
		CPPFLAGS="${CPPFLAGS} -DERIS_LIBDWARF_LIBDWARF_H=1"
	else
		cf_ensure_header '<libdwarf.h>'
	fi

	cf_test_program <<EOF
#ifdef ERIS_LIBDWARF_LIBDWARF_H
# include <libdwarf/libdwarf.h>
#else
# include <libdwarf.h>
#endif
int main () { return dwarf_init (0, 0, 0, 0, 0, 0); }
EOF
	cf_ensure_library -ldwarf -lelf

	cf_checking "for dwarf_pubtype_type_die_offset()"
	cf_test_program <<EOF
#ifdef ERIS_LIBDWARF_LIBDWARF_H
# include <libdwarf/libdwarf.h>
#else
# include <libdwarf.h>
#endif
int main () { return dwarf_pubtype_die_offset (0, 0, 0); }
EOF
	if cf_test_link__ -ldwarf -lelf
	then
		cf_check_result 'yes'
	else
		if cf_test_link__ -ldwarf -lelf \
			'-Ddwarf_pubtype_die_offset=dwarf_pubtype_type_die_offset'
		then
			# Nasty, nasty libdwarf
			CPPFLAGS="${CPPFLAGS} -DERIS_WORKAROUND_DWARF_PUBTYPE_DIE_OFFSET=1"
			cf_check_result 'using workaround'
		else
			cf_check_result 'no'
			cf_die 'Could not find dwarf_pubtype_die_offset() in -ldwarf'
		fi
	fi
fi


cf_test_function dlopen
if cf_test_failed
then
	cf_ensure_function dlopen -ldl
	LIBS="${LIBS} -ldl"
fi


##################################### Optional headers and libraries ######

cf_checking 'whether to use bundled Lua'
if ${enable_bundled_lua}
then
	lua_build_type='bundled'
	system_lua_bin=''
	cf_check_result yes

	if cf_test_function readline -lreadline
	then
		CPPFLAGS="${CPPFLAGS} -DLUA_USE_READLINE=1"
		LIBS="${LIBS} -lreadline"
	fi
else
	lua_build_type='system'
	cf_check_result no

	cf_checking 'for Lua interpreter'
	system_lua_bin=$(cf_choose_program lua-5.3 lua5.3 lua5 lua)
	if test "x${system_lua_bin}" = "x"
	then
		cf_check_result 'not found'
		cf_die 'Make sure that the Lua interpreter is in your $PATH'
	else
		cf_check_result "${system_lua_bin}"
	fi
fi


cf_checking 'whether to use libffi'
if ${enable_ffi}
then
	cf_check_result yes
	CPPFLAGS="${CPPFLAGS} -DERIS_FCALL_FFI=1"
	cf_pkg_config FFI 'libffi >= 3.2' || cf_die 'libffi not found'
else
	cf_check_result no
fi

####################################################### Final fixups ######

cf_build_conf <<EOF
obj      = ${objdir}
prefix   = ${PREFIX}
cc       = ${CC}
CFLAGS   = ${CFLAGS} ${FFI_CFLAGS} \${EXTRA_CFLAGS}
CPPFLAGS = ${CPPFLAGS} \${EXTRA_CPPFLAGS}
LDFLAGS  = ${LDFLAGS} ${FFI_LDFLAGS} \${EXTRA_LDFLAGS}
libs     = ${LIBS} \${EXTRA_LIBS}

lua_build = ${lua_build_type}
system_lua_bin = ${system_lua_bin}
libdwarf_build = ${libdwarf_build_type}
EOF

echo "build.conf written"
